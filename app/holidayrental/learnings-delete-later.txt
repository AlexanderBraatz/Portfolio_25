

Frontend

Building a stacking cards UI using scroll

I built an animation where cards stack on top of each other as the user scrolls down the page. To get this right, I had to pay close attention to how position: sticky, the scroll container height, card height, top alignment, and top margins all interact. The final effect uses position: sticky plus Framer Motion tracking of scroll progress to drive the stacking behaviour.

Building a user-controlled shuffle animation

I also created a playful “polaroid shuffle” animation so users can click through different room images. The main challenge was choosing the right moment in the animation to change z-index to avoid visible clipping as images overlap. Instead of using CSS keyframes, I tracked animation progress in component state so the user can drive the shuffle by clicking from one photo to the next.

Trade-offs

Custom dashboard instead of a stitched-together SaaS workflow

I chose to build a custom dashboard where the client can manage bookings and customer details in one place, rather than stitching together existing tools (e.g. forms + manual tracking + manual emails). This required more upfront work, but the result was a simpler and more automated workflow. The client valued having everything in one place and not needing to learn multiple systems.



Backend

Designing a robust event-driven architecture

I designed the booking system to tolerate failures and remain eventually consistent across distributed parts of the workflow. I did this by using idempotency keys to prevent duplicate email sends, and retry logic to ensure emails and database updates still complete after transient failures. I achieved this without adding explicit job queues by leaning on Stripe and Resend’s built-in retry and idempotency features.

Leveraging TypeScript generics

For the email-sending layer, I used TypeScript generics to strongly couple each email template with the props it expects. This makes it easy to add new templates while keeping type safety. TypeScript can validate at build time that the template and props match, which reduces the risk of runtime bugs and time-consuming email debugging. A union-based approach could work, but generics scale more cleanly as the number of templates grows.

Integrating Stripe

I chose Stripe for its developer experience and the quality of its dashboard (useful if the client ever needs to handle refunds). I implemented dynamic pricing on the server and embedded Stripe Checkout components into a custom checkout page, instead of using a redirect-to-Stripe URL flow. This kept the user experience cohesive, and it let the client set or adjust pricing from the admin dashboard rather than managing prices directly in Stripe.

Ensuring database security

I protected user data while still supporting database writes from unauthenticated users. I did this with RLS policies in Postgres, combined with tightly controlled usage of the service role key from server-only function calls.

Trade-offs
	1.	No explicit rate limiting: Unauthenticated users can trigger certain writes, but I assessed the likelihood and business impact of abuse as low for this project. Adding rate limiting infrastructure didn’t feel justified at this stage.
	2.	No separate email job queue: I relied on Resend retry logic plus idempotency keys, because the expected email volume is low enough that a dedicated queue would add complexity without clear upside.



Project delivery

Agile iteration with the client using prototypes

Close collaboration with the client improved the final outcome. Getting feedback early surfaced important insights while changes were still cheap, and reduced the amount of work I had to throw away later.

I also learned that details matter, even during early exploration. Keeping spelling, tone, and placeholder copy on-brand helped feedback sessions stay focused on the product, instead of getting distracted by avoidable rough edges.